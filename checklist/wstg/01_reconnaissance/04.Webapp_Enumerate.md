# üîç INFORMATION GATHERING | ENUMERATE APPLICATIONS ON WEBSERVER

## Comprehensive Web Application Enumeration & Discovery

### 1 Web Server Application Discovery
- **Port Scanning & Service Discovery:**
  - HTTP/HTTPS port scanning (80, 443, 8080, 8443)
  - Alternative web ports discovery (3000, 5000, 8000, 9000)
  - SSL/TLS service enumeration
  - Web service banner grabbing
  - HTTP vs HTTPS service comparison
  - Load balancer detection
  - Reverse proxy identification
  - Application server discovery

- **Virtual Host Enumeration:**
  - DNS-based virtual host discovery
  - IP-based virtual host identification
  - SNI-based HTTPS virtual host enumeration
  - Mass virtual hosting detection
  - Subdomain-to-application mapping
  - Wildcard DNS configuration testing
  - Header-based virtual host identification
  - Certificate-based virtual host discovery

### 2 Application Technology Identification
- **Web Framework Detection:**
  - Server header analysis and framework identification
  - X-Powered-By header examination
  - Cookie-based framework detection
  - URL pattern framework recognition
  - HTML markup framework signatures
  - JavaScript framework detection
  - CSS framework identification
  - Error message framework analysis

- **Programming Language Detection:**
  - File extension analysis (.php,  asp,  jsp,  py,  rb)
  - URL parameter pattern recognition
  - Session cookie naming conventions
  - Error message language signatures
  - Default file language detection
  - Header-based language identification
  - Response timing language analysis
  - Directory structure language patterns

- **Database Technology Detection:**
  - Connection string analysis
  - Error message database identification
  - Default database file patterns
  - ORM framework detection
  - Database-driven application recognition
  - Query parameter patterns
  - API endpoint database signatures
  - Administrative interface database detection

### 3 Content Management System (CMS) Enumeration
- **Popular CMS Detection:**
  - WordPress installation identification
  - Joomla installation detection
  - Drupal installation recognition
  - Magento e-commerce detection
  - Shopify store identification
  - Wix website detection
  - Squarespace site recognition
  - Custom CMS identification

- **CMS-Specific Enumeration:**
  - Default installation path testing
  - Administrative interface discovery
  - Plugin and module enumeration
  - Theme and template detection
  - Database prefix identification
  - User enumeration techniques
  - Version disclosure methods
  - Backup file discovery

### 4 Web Application Directory Enumeration
- **Common Directory Discovery:**
  - Administrative directory enumeration (/admin, /administrator)
  - Application directory discovery (/app, /application)
  - Configuration directory testing (/config, /conf)
  - Backup directory identification (/backup, /backups)
  - Log directory discovery (/logs, /log)
  - Temporary directory testing (/tmp, /temp)
  - Upload directory enumeration (/uploads, /files)
  - Source code directory discovery (/src, /source)

- **Framework-Specific Directory Enumeration:**
  - Laravel directory structure testing
  - Django project directory discovery
  - Ruby on Rails directory enumeration
  - Spring Boot application directory testing
  - ASP.NET directory structure discovery
  - Express.js directory enumeration
  - Flask application directory testing
  - Symfony directory discovery

### 5 File Enumeration & Discovery
- **Common File Discovery:**
  - Configuration file enumeration (.env, config.json, web.config)
  - Backup file discovery (.bak,  backup,  old)
  - Source code file exposure (.php,  java,  py)
  - Database file detection (.sql,  mdb,  db)
  - Log file discovery (.log,  txt)
  - Temporary file exposure (.tmp,  temp)
  - Documentation file discovery (.md,  txt,  pdf)
  - Certificate file detection (.pem,  crt,  key)

- **Application-Specific File Enumeration:**
  - Login page discovery (login.php, signin.aspx)
  - Registration page identification (register.jsp, signup.py)
  - Dashboard page enumeration (dashboard.html, admin.php)
  - API endpoint discovery (api/, rest/, graphql)
  - Web service file detection (wsdl, asmx, svc)
  - Mobile application backend discovery
  - Third-party integration files
  - Webhook endpoint enumeration

### 6 API Endpoint Discovery
- **REST API Enumeration:**
  - Common API path discovery (/api, /v1, /rest)
  - API documentation location testing (/docs, /swagger, /openapi)
  - GraphQL endpoint identification (/graphql, /query)
  - SOAP web service discovery
  - RPC endpoint enumeration
  - Webhook URL discovery
  - Authentication endpoint testing
  - Data export endpoint identification

- **API Parameter Discovery:**
  - Query parameter enumeration
  - Path parameter identification
  - Header parameter discovery
  - Body parameter analysis
  - Authentication parameter testing
  - Pagination parameter discovery
  - Filter parameter enumeration
  - Sort parameter identification

### 7 Authentication & Authorization Enumeration
- **Authentication Mechanism Discovery:**
  - Login form identification and analysis
  - SSO integration detection
  - OAuth/OIDC endpoint discovery
  - SAML authentication detection
  - Basic authentication testing
  - Digest authentication discovery
  - Certificate-based authentication
  - Multi-factor authentication detection

- **User & Role Enumeration:**
  - User registration endpoint discovery
  - Password reset functionality testing
  - User profile enumeration
  - Role-based access control mapping
  - Privilege escalation path discovery
  - Session management analysis
  - Access token endpoint discovery
  - Permission structure mapping

### 8 Third-Party Integration Discovery
- **External Service Detection:**
  - CDN integration identification
  - Analytics service discovery (Google Analytics, Matomo)
  - Advertising network detection
  - Social media integration testing
  - Payment gateway discovery
  - Email service detection
  - CRM integration identification
  - Marketing automation discovery

- **Library & Framework Detection:**
  - JavaScript library identification
  - CSS framework detection
  - Frontend framework discovery
  - UI component library testing
  - Chart and visualization library detection
  - Utility library discovery
  - Mobile framework identification
  - Progressive Web App (PWA) detection

### 9 Mobile Application Backend Discovery
- **Mobile API Enumeration:**
  - Mobile-specific endpoint discovery
  - Push notification service detection
  - Mobile authentication endpoint testing
  - Mobile analytics endpoint discovery
  - In-app purchase backend detection
  - Mobile storage service enumeration
  - Location service endpoint testing
  - Mobile sync service discovery

- **Cross-Platform App Detection:**
  - React Native backend enumeration
  - Flutter application backend discovery
  - Xamarin backend service testing
  - Ionic framework backend detection
  - Cordova/PhoneGap backend enumeration
  - NativeScript backend discovery
  - Progressive Web App backend testing

### 10 Automated Enumeration Framework
```yaml
Web Application Enumeration Pipeline:
  Discovery Phase:
    - Port scanning and service detection
    - Virtual host enumeration
    - Subdomain discovery
    - Technology stack identification
    - CMS detection and enumeration
    - Directory and file discovery
    - API endpoint enumeration
    - Third-party integration detection

  Analysis Phase:
    - Application architecture mapping
    - Technology dependency analysis
    - Authentication mechanism assessment
    - Authorization structure mapping
    - Data flow analysis
    - User role enumeration
    - Business logic understanding
    - Attack surface analysis

  Enumeration Phase:
    - Directory and file brute-forcing
    - Parameter discovery and testing
    - Hidden functionality discovery
    - Administrative interface enumeration
    - Backup file discovery
    - Source code exposure testing
    - Configuration file enumeration
    - Database exposure testing

  Validation Phase:
    - Manual verification of findings
    - False positive elimination
    - Risk assessment and prioritization
    - Exploitation feasibility analysis
    - Business impact assessment
    - Remediation planning
    - Reporting preparation
    - Continuous monitoring setup
```

### 11 Testing Tools and Commands
```bash
# Port Scanning and Service Discovery
nmap -sS -sV -p 80,443,8080,8443,3000,5000,8000,9000 target.com
masscan -p80,443,8000-9000 target.com --rate=1000

# Virtual Host Enumeration
gobuster vhost -u https://target.com -w /usr/share/wordlists/vhosts.txt
ffuf -u https://target.com -H "Host: FUZZ.target.com" -w vhosts.txt

# Subdomain Discovery
subfinder -d target.com -o subdomains.txt
amass enum -d target.com -o amass_results.txt
assetfinder --subs-only target.com | tee assetfinder.txt

# Directory and File Enumeration
gobuster dir -u https://target.com -w /usr/share/wordlists/dirb/common.txt
dirb https://target.com /usr/share/dirb/wordlists/common.txt
ffuf -u https://target.com/FUZZ -w directory-list-2.3-medium.txt

# Technology Detection
whatweb -v target.com
wappalyzer target.com
nmap --script http-enum,http-title -p 80,443 target.com

# CMS Detection
wpscan --url target.com --enumerate p,t,u
droopescan scan drupal -u target.com
joomscan -u target.com

# API Discovery
gobuster dir -u https://target.com -w api_words.txt -x json,yml,yaml,xml
arjun -u https://target.com/api/endpoint --get
```

### 12 Advanced Application Enumeration Payloads
```python
# Comprehensive Web Application Enumerator
import requests
import json
import re
from urllib.parse import urljoin, urlparse
import threading
from concurrent.futures import ThreadPoolExecutor

class WebApplicationEnumerator:
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (compatible; WebAppEnumerator/1.0)'
        })
        self.discovered_apps = {}
        self.technologies = {}

    def port_scanning(self, target_domain):
        """Perform web service port scanning"""
        common_web_ports = [80, 443, 8080, 8443, 3000, 5000, 8000, 9000]
        discovered_services = {}
        
        def scan_port(port):
            try:
                if port == 443:
                    url = f"https://{target_domain}:{port}"
                else:
                    url = f"http://{target_domain}:{port}"
                
                response = self.session.get(url, timeout=5, verify=False)
                if response.status_code < 500:
                    discovered_services[port] = {
                        'url': url,
                        'status_code': response.status_code,
                        'server_header': response.headers.get('Server', ''),
                        'title': self.extract_page_title(response.text),
                        'technologies': self.detect_technologies(response)
                    }
            except requests.RequestException:
                pass
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            executor.map(scan_port, common_web_ports)
        
        return discovered_services

    def virtual_host_enumeration(self, domain):
        """Enumerate virtual hosts"""
        vhosts = []
        
        # Common virtual host patterns
        vhost_patterns = [
            'www', 'api', 'admin', 'test', 'dev', 'staging',
            'mobile', 'app', 'web', 'secure', 'mail', 'blog',
            'shop', 'store', 'cdn', 'assets', 'static'
        ]
        
        for pattern in vhost_patterns:
            vhost = f"{pattern}.{domain}"
            try:
                response = self.session.get(
                    f"https://{domain}",
                    headers={'Host': vhost},
                    timeout=5
                )
                if response.status_code != 404:
                    vhosts.append({
                        'host': vhost,
                        'status_code': response.status_code,
                        'title': self.extract_page_title(response.text),
                        'content_length': len(response.content)
                    })
            except requests.RequestException:
                pass
        
        return vhosts

    def technology_detection(self, response):
        """Detect web technologies from response"""
        technologies = {
            'server_software': [],
            'programming_languages': [],
            'frameworks': [],
            'javascript_libraries': [],
            'css_frameworks': [],
            'analytics_services': [],
            'cms_platforms': [],
            'caching_solutions': []
        }
        
        content = response.text
        headers = str(response.headers)
        
        # Server software detection
        server_headers = [
            ('nginx', 'nginx'),
            ('apache', 'apache'),
            ('iis', 'iis'),
            ('tomcat', 'tomcat'),
            ('cloudflare', 'cloudflare'),
            ('cloudfront', 'amazon cloudfront')
        ]
        
        for pattern, name in server_headers:
            if pattern in headers.lower():
                technologies['server_software'].append(name)
        
        # Programming language detection
        language_patterns = [
            (r'\.php\b', 'php'),
            (r'\.aspx?\b', 'asp.net'),
            (r'\.jsp\b', 'java'),
            (r'\.py\b', 'python'),
            (r'\.rb\b', 'ruby'),
            (r'node\.js', 'node.js'),
            (r'django', 'python/django'),
            (r'flask', 'python/flask')
        ]
        
        for pattern, language in language_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                technologies['programming_languages'].append(language)
        
        # Framework detection
        framework_patterns = [
            (r'react', 'react'),
            (r'angular', 'angular'),
            (r'vue\.js', 'vue.js'),
            (r'jquery', 'jquery'),
            (r'bootstrap', 'bootstrap'),
            (r'laravel', 'laravel'),
            (r'rails', 'ruby on rails'),
            (r'spring', 'spring framework')
        ]
        
        for pattern, framework in framework_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                technologies['frameworks'].append(framework)
        
        # CMS detection
        cms_patterns = [
            (r'wp-content', 'wordpress'),
            (r'joomla', 'joomla'),
            (r'drupal', 'drupal'),
            (r'magento', 'magento'),
            (r'shopify', 'shopify'),
            (r'woocommerce', 'woocommerce'),
            (r'prestashop', 'prestashop')
        ]
        
        for pattern, cms in cms_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                technologies['cms_platforms'].append(cms)
        
        return technologies

    def directory_enumeration(self, base_url, wordlist_path):
        """Enumerate directories and files"""
        discovered_paths = []
        
        with open(wordlist_path, 'r') as wordlist:
            directories = [line.strip() for line in wordlist if line.strip()]
        
        def check_directory(directory):
            url = urljoin(base_url, directory)
            try:
                response = self.session.get(url, timeout=5)
                if response.status_code == 200:
                    discovered_paths.append({
                        'path': directory,
                        'url': url,
                        'status_code': response.status_code,
                        'content_type': response.headers.get('Content-Type', ''),
                        'size': len(response.content),
                        'title': self.extract_page_title(response.text)
                    })
                elif response.status_code in [301, 302, 307, 308]:
                    discovered_paths.append({
                        'path': directory,
                        'url': url,
                        'status_code': response.status_code,
                        'redirect_location': response.headers.get('Location', ''),
                        'type': 'redirect'
                    })
            except requests.RequestException:
                pass
        
        with ThreadPoolExecutor(max_workers=20) as executor:
            executor.map(check_directory, directories)
        
        return discovered_paths

    def api_endpoint_discovery(self, base_url):
        """Discover API endpoints"""
        api_endpoints = []
        
        common_api_paths = [
            'api', 'api/v1', 'api/v2', 'rest', 'rest/api',
            'graphql', 'query', 'oauth', 'auth', 'token',
            'users', 'products', 'orders', 'customers',
            'admin/api', 'mobile/api', 'webhook', 'callback'
        ]
        
        common_api_files = [
            'swagger.json', 'openapi.json', 'api-docs.json',
            'wsdl', 'api.yaml', 'api.yml', 'rest.php'
        ]
        
        # Check API directories
        for path in common_api_paths:
            url = urljoin(base_url, path)
            try:
                response = self.session.get(url, timeout=5)
                if response.status_code < 400:
                    api_endpoints.append({
                        'type': 'api_directory',
                        'path': path,
                        'url': url,
                        'status_code': response.status_code,
                        'content_type': response.headers.get('Content-Type', '')
                    })
            except requests.RequestException:
                pass
        
        # Check API documentation files
        for file in common_api_files:
            url = urljoin(base_url, file)
            try:
                response = self.session.get(url, timeout=5)
                if response.status_code == 200:
                    api_endpoints.append({
                        'type': 'api_documentation',
                        'file': file,
                        'url': url,
                        'content': response.text[:500] + '...' if len(response.text) > 500 else response.text
                    })
            except requests.RequestException:
                pass
        
        return api_endpoints

    def cms_specific_enumeration(self, cms_type, base_url):
        """Perform CMS-specific enumeration"""
        cms_findings = {}
        
        if cms_type.lower() == 'wordpress':
            cms_findings = self.enumerate_wordpress(base_url)
        elif cms_type.lower() == 'drupal':
            cms_findings = self.enumerate_drupal(base_url)
        elif cms_type.lower() == 'joomla':
            cms_findings = self.enumerate_joomla(base_url)
        
        return cms_findings

    def enumerate_wordpress(self, base_url):
        """Enumerate WordPress-specific paths and files"""
        wp_paths = [
            'wp-admin', 'wp-content', 'wp-includes',
            'wp-login.php', 'wp-config.php', 'xmlrpc.php',
            'wp-json', 'wp-admin/install.php', 'readme.html'
        ]
        
        wp_findings = {}
        
        for path in wp_paths:
            url = urljoin(base_url, path)
            try:
                response = self.session.get(url, timeout=5)
                if response.status_code < 400:
                    wp_findings[path] = {
                        'url': url,
                        'status_code': response.status_code,
                        'exists': True
                    }
            except requests.RequestException:
                wp_findings[path] = {'exists': False}
        
        return wp_findings

    def authentication_endpoint_discovery(self, base_url):
        """Discover authentication-related endpoints"""
        auth_endpoints = []
        
        common_auth_paths = [
            'login', 'signin', 'auth', 'authenticate',
            'logout', 'signout', 'register', 'signup',
            'password', 'reset', 'forgot', 'recover',
            'oauth', 'saml', 'openid', 'token', 'refresh'
        ]
        
        for path in common_auth_paths:
            url = urljoin(base_url, path)
            try:
                response = self.session.get(url, timeout=5)
                if response.status_code < 400:
                    auth_endpoints.append({
                        'type': 'authentication',
                        'path': path,
                        'url': url,
                        'status_code': response.status_code,
                        'form_present': '<form' in response.text.lower(),
                        'password_field': 'type="password"' in response.text.lower()
                    })
            except requests.RequestException:
                pass
        
        return auth_endpoints

    def extract_page_title(self, html_content):
        """Extract page title from HTML"""
        title_match = re.search(r'<title>(.*?)</title>', html_content, re.IGNORECASE)
        return title_match.group(1) if title_match else 'No title'

    def generate_enumeration_report(self):
        """Generate comprehensive enumeration report"""
        report = {
            'port_scanning': self.port_scanning(urlparse(self.base_url).netloc),
            'virtual_hosts': self.virtual_host_enumeration(urlparse(self.base_url).netloc),
            'technologies': self.technologies,
            'directories': self.directory_enumeration(self.base_url, 'common_directories.txt'),
            'api_endpoints': self.api_endpoint_discovery(self.base_url),
            'authentication_endpoints': self.authentication_endpoint_discovery(self.base_url),
            'cms_findings': {}
        }
        
        # CMS-specific enumeration if detected
        if any('wordpress' in tech for tech in self.technologies.get('cms_platforms', [])):
            report['cms_findings']['wordpress'] = self.enumerate_wordpress(self.base_url)
        
        return report

# Advanced Application Fingerprinter
class ApplicationFingerprinter:
    def __init__(self):
        self.technology_signatures = self.load_technology_signatures()
    
    def load_technology_signatures(self):
        """Load technology detection signatures"""
        return {
            'javascript_frameworks': {
                'react': ['react', 'react-dom'],
                'angular': ['angular', 'ng-'],
                'vue': ['vue', 'v-'],
                'jquery': ['jquery']
            },
            'css_frameworks': {
                'bootstrap': ['bootstrap', 'btn-'],
                'foundation': ['foundation'],
                'bulma': ['bulma'],
                'tailwind': ['tailwind']
            },
            'analytics': {
                'google_analytics': ['ga(', 'gtag('],
                'google_tag_manager': ['gtm.js'],
                'facebook_pixel': ['fbq('],
                'hotjar': ['hotjar']
            }
        }

    def fingerprint_from_response(self, response):
        """Fingerprint technologies from HTTP response"""
        fingerprints = {}
        
        # Header-based fingerprinting
        headers = str(response.headers).lower()
        for tech_type, signatures in self.technology_signatures.items():
            for tech_name, patterns in signatures.items():
                for pattern in patterns:
                    if pattern in headers:
                        if tech_type not in fingerprints:
                            fingerprints[tech_type] = []
                        fingerprints[tech_type].append(tech_name)
        
        # Content-based fingerprinting
        content = response.text.lower()
        for tech_type, signatures in self.technology_signatures.items():
            for tech_name, patterns in signatures.items():
                for pattern in patterns:
                    if pattern in content:
                        if tech_type not in fingerprints:
                            fingerprints[tech_type] = []
                        if tech_name not in fingerprints[tech_type]:
                            fingerprints[tech_type].append(tech_name)
        
        return fingerprints

# Mobile Application Backend Detector
class MobileBackendDetector:
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()

    def detect_mobile_endpoints(self):
        """Detect mobile-specific API endpoints"""
        mobile_endpoints = []
        
        mobile_paths = [
            'mobile', 'api/mobile', 'app', 'api/app',
            'ios', 'android', 'api/v1/mobile',
            'push', 'notification', 'fcm', 'apns'
        ]
        
        for path in mobile_paths:
            url = urljoin(self.base_url, path)
            try:
                response = self.session.get(url, timeout=5)
                if response.status_code < 400:
                    mobile_endpoints.append({
                        'path': path,
                        'url': url,
                        'status_code': response.status_code,
                        'content_type': response.headers.get('Content-Type', '')
                    })
            except requests.RequestException:
                pass
        
        return mobile_endpoints

    def detect_mobile_frameworks(self, response):
        """Detect mobile framework usage"""
        mobile_frameworks = []
        
        content = response.text.lower()
        
        framework_indicators = {
            'react_native': ['react-native', 'reactnative'],
            'flutter': ['flutter'],
            'ionic': ['ionic', 'cordova', 'phonegap'],
            'xamarin': ['xamarin'],
            'native_script': ['nativescript']
        }
        
        for framework, indicators in framework_indicators.items():
            for indicator in indicators:
                if indicator in content:
                    mobile_frameworks.append(framework)
                    break
        
        return mobile_frameworks
```

### 13 Continuous Application Monitoring
```python
# Web Application Change Monitor
class ApplicationChangeMonitor:
    def __init__(self, target_applications):
        self.target_applications = target_applications
        self.known_state = {}
        self.monitoring_interval = 3600  # 1 hour

    def setup_continuous_monitoring(self):
        """Set up continuous application monitoring"""
        for app_url in self.target_applications:
            current_state = self.scan_application(app_url)
            previous_state = self.known_state.get(app_url)
            
            if previous_state:
                changes = self.detect_application_changes(previous_state, current_state)
                if changes:
                    self.alert_application_changes(app_url, changes)
            
            self.known_state[app_url] = current_state

    def scan_application(self, app_url):
        """Perform comprehensive application scan"""
        enumerator = WebApplicationEnumerator(app_url)
        return enumerator.generate_enumeration_report()

    def detect_application_changes(self, old_state, new_state):
        """Detect changes in application state"""
        changes = {
            'new_endpoints': [],
            'modified_endpoints': [],
            'removed_endpoints': [],
            'technology_changes': [],
            'new_virtual_hosts': [],
            'port_changes': []
        }
        
        # Compare endpoints
        old_endpoints = set(
            ep['url'] for ep in old_state.get('api_endpoints', []) + 
            old_state.get('authentication_endpoints', []) +
            [item for item in old_state.get('directories', []) if 'url' in item]
        )
        
        new_endpoints = set(
            ep['url'] for ep in new_state.get('api_endpoints', []) + 
            new_state.get('authentication_endpoints', []) +
            [item for item in new_state.get('directories', []) if 'url' in item]
        )
        
        changes['new_endpoints'] = list(new_endpoints - old_endpoints)
        changes['removed_endpoints'] = list(old_endpoints - new_endpoints)
        
        # Compare technologies
        old_tech = old_state.get('technologies', {})
        new_tech = new_state.get('technologies', {})
        
        for tech_category in set(old_tech.keys()) | set(new_tech.keys()):
            old_items = set(old_tech.get(tech_category, []))
            new_items = set(new_tech.get(tech_category, []))
            
            if old_items != new_items:
                changes['technology_changes'].append({
                    'category': tech_category,
                    'added': list(new_items - old_items),
                    'removed': list(old_items - new_items)
                })
        
        return changes

    def alert_application_changes(self, app_url, changes):
        """Alert on application changes"""
        alert_data = {
            'timestamp': datetime.now().isoformat(),
            'application': app_url,
            'changes': changes,
            'risk_assessment': self.assess_change_risk(changes),
            'recommendations': self.generate_change_recommendations(changes)
        }
        
        self.report_to_security_team(alert_data)
        logger.warning(f"Application changes detected: {alert_data}")

# Automated Application Discovery Engine
class ApplicationDiscoveryEngine:
    def __init__(self, target_domain):
        self.target_domain = target_domain
        self.discovered_applications = []

    def comprehensive_discovery(self):
        """Perform comprehensive application discovery"""
        discovery_results = {
            'subdomain_applications': self.discover_subdomain_applications(),
            'port_based_applications': self.discover_port_applications(),
            'virtual_host_applications': self.discover_virtual_host_applications(),
            'path_based_applications': self.discover_path_applications()
        }
        
        # Consolidate all discovered applications
        all_applications = []
        for category, apps in discovery_results.items():
            all_applications.extend(apps)
        
        self.discovered_applications = all_applications
        return discovery_results

    def discover_subdomain_applications(self):
        """Discover applications on subdomains"""
        subdomain_apps = []
        
        # Use subdomain enumeration tools
        subdomains = self.enumerate_subdomains()
        
        for subdomain in subdomains:
            app_url = f"https://{subdomain}"
            try:
                response = requests.get(app_url, timeout=5)
                if response.status_code < 400:
                    subdomain_apps.append({
                        'url': app_url,
                        'subdomain': subdomain,
                        'status_code': response.status_code,
                        'title': self.extract_page_title(response.text),
                        'technologies': self.detect_technologies(response)
                    })
            except requests.RequestException:
                pass
        
        return subdomain_apps

    def discover_port_applications(self):
        """Discover applications on different ports"""
        port_apps = []
        common_ports = [80, 443, 8080, 8443, 3000, 5000, 8000, 9000]
        
        for port in common_ports:
            if port == 443:
                url = f"https://{self.target_domain}:{port}"
            else:
                url = f"http://{self.target_domain}:{port}"
            
            try:
                response = requests.get(url, timeout=5, verify=False)
                if response.status_code < 400:
                    port_apps.append({
                        'url': url,
                        'port': port,
                        'status_code': response.status_code,
                        'title': self.extract_page_title(response.text),
                        'technologies': self.detect_technologies(response)
                    })
            except requests.RequestException:
                pass
        
        return port_apps

    def discover_virtual_host_applications(self):
        """Discover applications on virtual hosts"""
        vhost_apps = []
        common_vhosts = ['www', 'api', 'admin', 'app', 'mobile', 'test']
        
        for vhost in common_vhosts:
            hostname = f"{vhost}.{self.target_domain}"
            try:
                response = requests.get(
                    f"https://{self.target_domain}",
                    headers={'Host': hostname},
                    timeout=5
                )
                if response.status_code < 400:
                    vhost_apps.append({
                        'url': f"https://{hostname}",
                        'vhost': hostname,
                        'status_code': response.status_code,
                        'title': self.extract_page_title(response.text),
                        'technologies': self.detect_technologies(response)
                    })
            except requests.RequestException:
                pass
        
        return vhost_apps

    def discover_path_applications(self):
        """Discover applications in different paths"""
        path_apps = []
        common_paths = ['/app', '/admin', '/api', '/mobile', '/test']
        
        for path in common_paths:
            url = f"https://{self.target_domain}{path}"
            try:
                response = requests.get(url, timeout=5)
                if response.status_code < 400:
                    path_apps.append({
                        'url': url,
                        'path': path,
                        'status_code': response.status_code,
                        'title': self.extract_page_title(response.text),
                        'technologies': self.detect_technologies(response)
                    })
            except requests.RequestException:
                pass
        
        return path_apps
```

### 14 Risk Assessment Matrix
```yaml
Web Application Enumeration Risk Assessment:
  Critical Risk Findings:
    - Exposed administrative interfaces without authentication
    - Database configuration files with plaintext credentials
    - Source code exposure in web-accessible directories
    - Backup files containing sensitive application data
    - Default application installations with known vulnerabilities
    - Exposed version control repositories (.git,  svn)
    - Unprotected API endpoints with sensitive data
    - Development and testing environments exposed to internet

  High Risk Findings:
    - Outdated software versions with known vulnerabilities
    - Exposed application documentation with internal information
    - Unrestricted file upload functionality
    - Directory listing enabled on sensitive directories
    - Verbose error messages revealing system information
    - Hardcoded API keys and credentials in client-side code
    - Missing security headers and protections
    - Unpatched security vulnerabilities in discovered applications

  Medium Risk Findings:
    - Information disclosure through metafiles (robots.txt, sitemap.xml)
    - Exposed user enumeration functionality
    - Predictable resource locations
    - Unnecessary HTTP methods enabled
    - Default application files and samples
    - Mixed content issues
    - Missing security controls on non-critical endpoints
    - Information leakage through response headers

  Low Risk Findings:
    - Common application paths accessible but properly secured
    - Standard technology stack without known vulnerabilities
    - Proper error handling and information disclosure controls
    - Security headers properly implemented
    - Authentication required for sensitive functionality
    - Regular security updates and patches
    - Proper access control implementation
    - Security monitoring and logging in place
```

### 15 Defense & Protection Testing
```python
# Application Enumeration Protection Tester
class EnumerationProtectionTester:
    def __init__(self, target_url):
        self.target_url = target_url
        self.session = requests.Session()

    def test_enumeration_protections(self):
        """Test protections against application enumeration"""
        tests = {
            'information_disclosure': self.test_information_disclosure(),
            'directory_listing': self.test_directory_listing(),
            'error_handling': self.test_error_handling(),
            'access_controls': self.test_access_controls(),
            'obfuscation_effectiveness': self.test_obfuscation_effectiveness()
        }
        return tests

    def test_information_disclosure(self):
        """Test for information disclosure vulnerabilities"""
        disclosure_tests = {}
        
        # Test headers for information disclosure
        response = self.session.get(self.target_url, timeout=10)
        headers = response.headers
        
        sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
        found_disclosures = []
        
        for header in sensitive_headers:
            if header in headers:
                found_disclosures.append({
                    'header': header,
                    'value': headers[header],
                    'risk': 'MEDIUM'
                })
        
        disclosure_tests['header_disclosure'] = found_disclosures
        
        # Test error pages for information disclosure
        error_tests = self.test_error_pages()
        disclosure_tests['error_disclosure'] = error_tests
        
        return disclosure_tests

    def test_directory_listing(self):
        """Test for directory listing vulnerabilities"""
        test_directories = [
            '/images/', '/css/', '/js/', '/uploads/', '/backup/',
            '/admin/', '/api/', '/config/', '/logs/'
        ]
        
        listing_vulnerabilities = []
        
        for directory in test_directories:
            url = urljoin(self.target_url, directory)
            try:
                response = self.session.get(url, timeout=5)
                if 'index of' in response.text.lower():
                    listing_vulnerabilities.append({
                        'directory': directory,
                        'url': url,
                        'risk': 'HIGH',
                        'evidence': 'Directory listing enabled'
                    })
            except requests.RequestException:
                pass
        
        return listing_vulnerabilities

    def test_error_handling(self):
        """Test error handling for information disclosure"""
        error_tests = {}
        
        test_paths = [
            '/nonexistent-page-12345',
            '/../etc/passwd',
            '/api/invalid-endpoint',
            '/admin/../config'
        ]
        
        for path in test_paths:
            url = urljoin(self.target_url, path)
            try:
                response = self.session.get(url, timeout=5)
                
                error_analysis = {
                    'status_code': response.status_code,
                    'stack_trace_exposed': any(term in response.text.lower() 
                                             for term in ['stack trace', 'exception', 'at line']),
                    'file_paths_exposed': any(term in response.text 
                                            for term in ['/var/www/', 'c:\\inetpub\\', '/home/']),
                    'framework_info_exposed': any(term in response.text.lower()
                                                for term in ['django', 'rails', 'laravel', 'spring'])
                }
                
                error_tests[path] = error_analysis
                
            except requests.RequestException:
                error_tests[path] = {'error': 'Request failed'}
        
        return error_tests

    def test_access_controls(self):
        """Test access controls for sensitive paths"""
        sensitive_paths = [
            '/admin/', '/administrator/', '/wp-admin/',
            '/config/', '/backup/', '/database/',
            '/.git/', '/.env', '/web.config'
        ]
        
        access_test_results = {}
        
        for path in sensitive_paths:
            url = urljoin(self.target_url, path)
            try:
                response = self.session.get(url, timeout=5)
                
                access_test_results[path] = {
                    'status_code': response.status_code,
                    'accessible': response.status_code == 200,
                    'protected': response.status_code in [401, 403, 404],
                    'redirects_to_login': 'login' in response.url.lower() if response.history else False
                }
                
            except requests.RequestException:
                access_test_results[path] = {'error': 'Request failed'}
        
        return access_test_results

    def generate_protection_report(self):
        """Generate comprehensive protection assessment report"""
        protection_tests = self.test_enumeration_protections()
        
        report = {
            'information_disclosure_assessment': protection_tests['information_disclosure'],
            'directory_listing_assessment': protection_tests['directory_listing'],
            'error_handling_assessment': protection_tests['error_handling'],
            'access_control_assessment': protection_tests['access_controls'],
            'overall_protection_score': self.calculate_protection_score(protection_tests),
            'recommendations': self.generate_protection_recommendations(protection_tests)
        }
        
        return report
```

### 16 Remediation Checklist
```markdown
## ‚úÖ WEB APPLICATION ENUMERATION REMEDIATION CHECKLIST

### Information Disclosure Prevention:
- [ ] Remove or obfuscate server headers (Server, X-Powered-By)
- [ ] Implement custom error pages without stack traces
- [ ] Remove sensitive information from comments and metadata
- [ ] Secure configuration files and environment variables
- [ ] Implement proper access controls for sensitive directories
- [ ] Remove default files and sample applications
- [ ] Secure version control repositories
- [ ] Regular security headers implementation

### Access Control Implementation:
- [ ] Implement proper authentication for administrative interfaces
- [ ] Restrict directory listing on web servers
- [ ] Implement IP-based access controls for sensitive areas
- [ ] Configure proper file permissions
- [ ] Implement role-based access control (RBAC)
- [ ] Regular access control reviews and testing
- [ ] Implement multi-factor authentication for critical areas
- [ ] Monitor and log access attempts

### Application Hardening:
- [ ] Remove unnecessary applications and services
- [ ] Update and patch all software components
- [ ] Implement web application firewalls (WAF)
- [ ] Configure security headers (CSP, HSTS, X-Frame-Options)
- [ ] Implement input validation and output encoding
- [ ] Regular vulnerability scanning and penetration testing
- [ ] Secure development lifecycle implementation
- [ ] Code review and security testing

### Monitoring & Detection:
- [ ] Implement application change detection
- [ ] Monitor for enumeration and scanning activities
- [ ] Set up alerts for suspicious access patterns
- [ ] Implement SIEM for security event correlation
- [ ] Regular security log reviews
- [ ] Implement intrusion detection systems (IDS)
- [ ] Monitor for new application deployments
- [ ] Continuous security assessment

### Network Security:
- [ ] Implement network segmentation
- [ ] Configure firewalls to restrict unnecessary ports
- [ ] Use reverse proxies for additional security
- [ ] Implement SSL/TLS termination properly
- [ ] Regular network security assessments
- [ ] Implement DDoS protection
- [ ] Secure load balancer configurations
- [ ] Network access control implementation

### Development Security:
- [ ] Implement secure coding standards
- [ ] Conduct security training for developers
- [ ] Use automated security testing in CI/CD
- [ ] Implement secret management solutions
- [ ] Regular dependency vulnerability scanning
- [ ] Secure API development practices
- [ ] Mobile application security testing
- [ ] Third-party component security assessment

### Incident Response:
- [ ] Establish application security incident response plan
- [ ] Implement rapid deployment rollback capabilities
- [ ] Conduct regular incident response drills
- [ ] Maintain application inventory and documentation
- [ ] Establish communication protocols for security incidents
- [ ] Implement forensic capabilities
- [ ] Regular backup and recovery testing
- [ ] Business continuity planning

### Policy & Governance:
- [ ] Develop application security policies
- [ ] Establish security requirements for new applications
- [ ] Implement security compliance monitoring
- [ ] Regular security awareness training
- [ ] Establish security metrics and reporting
- [ ] Implement third-party risk management
- [ ] Regular policy review and updates
- [ ] Security governance framework implementation
```

### 17 Secure Configuration Examples
```nginx
# Nginx Configuration for Application Enumeration Protection
server {
    listen 80;
    server_name example.com;
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Content-Security-Policy "default-src 'self'" always;
    
    # Remove server tokens
    server_tokens off;
    
    # Block sensitive directories
    location ~ /\. {
        deny all;
        return 404;
    }
    
    location ~ /(config|backup|database|logs)/ {
        deny all;
        return 404;
    }
    
    location ~* \.(env|config|sql|bak|backup|old)$ {
        deny all;
        return 404;
    }
    
    # Disable directory listing
    autoindex off;
    
    # Custom error pages
    error_page 404 /404.html;
    error_page 500 502 503 504 /50x.html;
    
    location = /404.html {
        internal;
        return 404 'Page not found';
    }
    
    location = /50x.html {
        internal;
        return 500 'Server error';
    }
    
    # Rate limiting for enumeration protection
    limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
    
    location / {
        limit_req zone=one burst=5;
        # Application configuration
    }
    
    # API endpoint protection
    location /api/ {
        limit_req zone=one burst=10;
        # Additional API security headers
        add_header X-API-Version "1.0" always;
    }
}

# Apache Configuration for Enumeration Protection
ServerTokens Prod
ServerSignature Off
TraceEnable Off

# Security headers
Header always set X-Frame-Options "SAMEORIGIN"
Header always set X-XSS-Protection "1; mode=block"
Header always set X-Content-Type-Options "nosniff"
Header always set Referrer-Policy "strict-origin-when-cross-origin"

# Block sensitive files
<FilesMatch "^\.">
    Order allow,deny
    Deny from all
</FilesMatch>

<FilesMatch "\.(env|config|sql|bak|backup|old)$">
    Order allow,deny
    Deny from all
</FilesMatch>

# Disable directory listing
Options -Indexes

# Custom error documents
ErrorDocument 404 /404.html
ErrorDocument 500 /500.html

# Rate limiting
<IfModule mod_ratelimit.c>
    <Location "/">
        SetOutputFilter RATE_LIMIT
        SetEnv rate-limit 1
        SetEnv rate-initial-burst 5
    </Location>
</IfModule>
```

```python
# Django Settings for Enumeration Protection
# settings.py

import os
from pathlib import Path

# Security settings
DEBUG = False
SECRET_KEY = os.environ.get('SECRET_KEY')

# Security headers
SECURE_CONTENT_TYPE_NOSNIFF = True
SECURE_BROWSER_XSS_FILTER = True
X_FRAME_OPTIONS = 'DENY'
SECURE_SSL_REDIRECT = True
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True
SECURE_HSTS_SECONDS = 31536000  # 1 year
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

# Custom middleware for additional protection
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    # Custom protection middleware
    'myapp.middleware.EnumerationProtectionMiddleware',
]

# Custom middleware class
class EnumerationProtectionMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        self.sensitive_paths = [
            '/admin/', '/api/', '/config/', '/backup/',
            '/.git', '/.env', '/wp-admin/'
        ]

    def __call__(self, request):
        path = request.path
        
        # Block access to sensitive paths
        for sensitive_path in self.sensitive_paths:
            if sensitive_path in path:
                from django.http import HttpResponseForbidden
                return HttpResponseForbidden()
        
        response = self.get_response(request)
        
        # Remove identifying headers
        if 'Server' in response:
            del response['Server']
        if 'X-Powered-By' in response:
            del response['X-Powered-By']
        
        return response

# Logging configuration to avoid information disclosure
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.FileHandler',
            'filename': '/var/log/django/app.log',
            'formatter': 'verbose',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['file'],
            'level': 'INFO',
            'propagate': True,
        },
    },
}
```

### 18 Testing Completion Checklist
```markdown
## ‚úÖ WEB APPLICATION ENUMERATION TESTING COMPLETION CHECKLIST

### Port Scanning & Service Discovery:
- [ ] HTTP/HTTPS port scanning completed
- [ ] Alternative web port discovery completed
- [ ] SSL/TLS service enumeration completed
- [ ] Web service banner grabbing completed
- [ ] Load balancer detection completed
- [ ] Reverse proxy identification completed
- [ ] Application server discovery completed
- [ ] Service mapping completed

### Virtual Host & Subdomain Enumeration:
- [ ] DNS-based virtual host discovery completed
- [ ] IP-based virtual host identification completed
- [ ] SNI-based HTTPS virtual host enumeration completed
- [ ] Mass virtual hosting detection completed
- [ ] Subdomain-to-application mapping completed
- [ ] Wildcard DNS configuration testing completed
- [ ] Header-based virtual host identification completed
- [ ] Certificate-based virtual host discovery completed

### Technology Identification:
- [ ] Web framework detection completed
- [ ] Programming language detection completed
- [ ] Database technology detection completed
- [ ] Server software identification completed
- [ ] JavaScript framework detection completed
- [ ] CSS framework identification completed
- [ ] Analytics service detection completed
- [ ] Third-party integration discovery completed

### CMS Enumeration:
- [ ] WordPress installation identification completed
- [ ] Joomla installation detection completed
- [ ] Drupal installation recognition completed
- [ ] Magento e-commerce detection completed
- [ ] Shopify store identification completed
- [ ] Custom CMS identification completed
- [ ] CMS version disclosure testing completed
- [ ] CMS-specific vulnerability assessment completed

### Directory & File Enumeration:
- [ ] Common directory discovery completed
- [ ] Application directory enumeration completed
- [ ] Configuration directory testing completed
- [ ] Backup directory identification completed
- [ ] Framework-specific directory enumeration completed
- [ ] File extension analysis completed
- [ ] Backup file discovery completed
- [ ] Source code exposure testing completed

### API Endpoint Discovery:
- [ ] REST API enumeration completed
- [ ] GraphQL endpoint identification completed
- [ ] SOAP web service discovery completed
- [ ] API documentation location testing completed
- [ ] Webhook URL discovery completed
- [ ] Authentication endpoint testing completed
- [ ] API parameter discovery completed
- [ ] Mobile API endpoint enumeration completed

### Authentication & Authorization Enumeration:
- [ ] Login form identification completed
- [ ] SSO integration detection completed
- [ ] OAuth/OIDC endpoint discovery completed
- [ ] User registration endpoint testing completed
- [ ] Password reset functionality testing completed
- [ ] User profile enumeration completed
- [ ] Role-based access control mapping completed
- [ ] Privilege escalation path discovery completed

### Impact Assessment:
- [ ] Application architecture mapping completed
- [ ] Attack surface analysis completed
- [ ] Risk assessment and prioritization completed
- [ ] Business impact assessment completed
- [ ] Security control evaluation completed
- [ ] Remediation priority assignment completed
- [ ] Monitoring recommendation development completed
- [ ] Reporting completion
```

### 19 Executive Reporting Template
```markdown
# Web Application Enumeration Assessment Report

## Executive Summary
- Total applications discovered: [Number]
- Critical security findings: [Number]
- High-risk vulnerabilities: [Number]
- Exposed administrative interfaces: [Number]
- Outdated software components: [Number]
- Overall enumeration risk score: [A-F Grade]

## Critical Findings
### [Critical Finding Title]
- **Application Type:** [Web Application/API/Mobile Backend]
- **Discovery Method:** [Port Scanning/Virtual Host/Directory Enumeration]
- **Vulnerability Type:** [Information Disclosure/Unauthorized Access/Configuration Exposure]
- **Impact:** [System Compromise/Data Breach/Service Disruption]
- **Exploitation Complexity:** [Low/Medium/High]
- **Remediation Priority:** [Critical/High/Medium/Low]

## Technical Analysis
### Application Discovery Methodology
1. **Enumeration Techniques**
   - Primary discovery methods: [Port Scanning/Subdomain Enumeration/Virtual Host Testing]
   - Technology identification: [Header Analysis/Content Fingerprinting/Error Analysis]
   - Application mapping: [Directory Enumeration/API Discovery/Authentication Testing]

2. **Discovered Applications**
   - Application inventory: [List of Discovered Applications]
   - Technology stack: [Server Software/Frameworks/Databases]
   - Exposure level: [Internet-Facing/Internal/Development]
   - Security posture: [Well-Secured/Partially Secured/Unsecured]

3. **Security Assessment**
   - Information disclosure: [Headers/Error Messages/Configuration Files]
   - Access control issues: [Unauthenticated Access/Weak Authentication/Authorization Bypass]
   - Configuration weaknesses: [Default Installations/Unpatched Software/Insecure Settings]
   - Business impact: [Data Exposure/Service Disruption/Reputation Damage]

## Proof of Concept
### Enumeration Demonstration
```http
[Example of enumeration commands and discovered applications]
```

### Impact Verification
- [ ] Application accessibility confirmed
- [ ] Technology stack verified
- [ ] Security vulnerabilities validated
- [ ] Access control issues demonstrated
- [ ] Business impact assessed
- [ ] Exploitation feasibility evaluated
- [ ] Remediation requirements identified
- [ ] Monitoring gaps documented

## Remediation Recommendations
### Immediate Actions
- [ ] Secure exposed administrative interfaces
- [ ] Remove or protect sensitive configuration files
- [ ] Implement proper access controls
- [ ] Update outdated software components
- [ ] Implement security headers and protections

### Medium-term Improvements
- [ ] Establish application inventory and management
- [ ] Implement continuous security monitoring
- [ ] Conduct developer security training
- [ ] Enhance security controls and configurations
- [ ] Regular security assessments and testing

### Long-term Strategies
- [ ] Develop comprehensive application security program
- [ ] Implement secure development lifecycle
- [ ] Establish security governance framework
- [ ] Continuous security improvement
- [ ] Regular policy review and updates

## Risk Assessment Summary
- **Overall Risk Level:** [Critical/High/Medium/Low]
- **Business Impact:** [Severe/Moderate/Minor]
- **Exploitation Likelihood:** [Certain/Likely/Possible/Unlikely]
- **Remediation Timeline:** [Immediate/1-2 weeks/1+ month]
- **Compliance Impact:** [Regulatory violations/Standards non-compliance]
- **Attack Surface:** [Significantly Expanded/Moderately Expanded/Minimally Expanded]
- **Security Control Gaps:** [Major/Moderate/Minor]
```

This comprehensive Web Application Enumeration checklist provides security professionals with complete methodology for discovering, analyzing, and assessing web applications on target systems. The framework covers port scanning, virtual host enumeration, technology identification, CMS detection, API discovery, and comprehensive security assessment to identify and mitigate risks associated with exposed web applications.